# NIFTY LEGACY DATA MONTHLY ANALYSIS
SELECT t.month_start::DATE as month_start, (MAX(high_index_value) - MIN(low_index_value))::integer AS range, f.symbol, MIN(o.trade_date) AS min_trade_date, MAX(o.trade_date) AS max_trade_date, MIN(low_index_value) AS min_price,  MAX(high_index_value) AS max_price, ROUND(SUM(closing_index_value)/COUNT(*)) AS avg_price, ROUND(stddev(closing_index_value)) AS stddev, (stddev(closing_index_value)/avg(closing_index_value) * 100)::integer AS coeff_variation FROM idx_history o INNER JOIN fno_index_symbols f ON f.symbol = o.symbol AND f.active = true AND f.symbol = 'NIFTY' AND o.trade_date IS NOT NULL INNER JOIN (SELECT trade_date, date_trunc('Month',trade_date) AS month_start FROM trade_dates WHERE trade_date <= now()::date ORDER BY trade_date DESC) AS t ON o.trade_date = t.trade_date GROUP BY f.symbol, t.month_start ORDER BY t.month_start, (stddev(closing_index_value)/avg(closing_index_value) * 100)::integer DESC;

# BANKNIFTY LEGACY DATA MONTHLY ANALYSIS
SELECT t.month_start::DATE as month_start, (MAX(high_index_value) - MIN(low_index_value))::integer AS range, f.symbol, MIN(o.trade_date) AS min_trade_date, MAX(o.trade_date) AS max_trade_date, MIN(low_index_value) AS min_price,  MAX(high_index_value) AS max_price, ROUND(SUM(closing_index_value)/COUNT(*)) AS avg_price, ROUND(stddev(closing_index_value)) AS stddev, (stddev(closing_index_value)/avg(closing_index_value) * 100)::integer AS coeff_variation FROM idx_history o INNER JOIN fno_index_symbols f ON f.symbol = o.symbol AND f.active = true AND f.symbol = 'BANKNIFTY' AND o.trade_date IS NOT NULL INNER JOIN (SELECT trade_date, date_trunc('Month',trade_date) AS month_start FROM trade_dates WHERE trade_date <= now()::date ORDER BY trade_date DESC) AS t ON o.trade_date = t.trade_date GROUP BY f.symbol, t.month_start ORDER BY t.month_start, (stddev(closing_index_value)/avg(closing_index_value) * 100)::integer DESC;

# EQUITY LAST 20 DAYS DATA ANALYSIS
SELECT f.symbol, MIN(e.trade_date) AS min_trade_date, MAX(e.trade_date) AS max_trade_date, MIN(day_low) AS min_price,  MAX(day_high) AS max_price, SUM(close_price)/COUNT(*) AS avg_price, stddev(close_price) AS stddev, (stddev(close_price)/avg(close_price) * 100)::integer AS coeff_variation FROM eq_history e INNER JOIN fno_stock_symbols f ON f.symbol = e.symbol AND f.active = true AND e.series = 'EQ' AND e.trade_date IS NOT NULL INNER JOIN (SELECT trade_date FROM trade_dates WHERE trade_date <= now()::date ORDER BY trade_date DESC LIMIT 20) AS t ON e.trade_date = t.trade_date GROUP BY f.symbol HAVING COUNT(*) >= 20 ORDER BY (stddev(close_price)/avg(close_price) * 100)::integer DESC LIMIT 20

# EQUITY STOCKS WITH LEAST VOLATILITY (LAST 20 DAYS + 40 DAYS + 60 DAYS)
(SELECT f.symbol FROM eq_history e INNER JOIN fno_stock_symbols f ON f.symbol = e.symbol AND f.active = true AND e.series = 'EQ' AND e.trade_date IS NOT NULL INNER JOIN (SELECT trade_date FROM trade_dates WHERE trade_date < '2022-02-01' ORDER BY trade_date DESC LIMIT 20) AS t ON e.trade_date = t.trade_date GROUP BY f.symbol HAVING COUNT(*) >= 20 ORDER BY (stddev(close_price)/avg(close_price) * 100)::integer DESC LIMIT 20)
INTERSECT
(SELECT f.symbol FROM eq_history e INNER JOIN fno_stock_symbols f ON f.symbol = e.symbol AND f.active = true AND e.series = 'EQ' AND e.trade_date IS NOT NULL INNER JOIN (SELECT trade_date FROM trade_dates WHERE trade_date < '2022-02-01' ORDER BY trade_date DESC LIMIT 40) AS t ON e.trade_date = t.trade_date GROUP BY f.symbol HAVING COUNT(*) >= 40 ORDER BY (stddev(close_price)/avg(close_price) * 100)::integer DESC LIMIT 20)
INTERSECT
(SELECT f.symbol FROM eq_history e INNER JOIN fno_stock_symbols f ON f.symbol = e.symbol AND f.active = true AND e.series = 'EQ' AND e.trade_date IS NOT NULL INNER JOIN (SELECT trade_date FROM trade_dates WHERE trade_date < '2022-02-01' ORDER BY trade_date DESC LIMIT 60) AS t ON e.trade_date = t.trade_date GROUP BY f.symbol HAVING COUNT(*) >= 60 ORDER BY (stddev(close_price)/avg(close_price) * 100)::integer DESC LIMIT 20)

# EQUITY STOCKS WITH LEAST VOLATILITY LAST 20 DAYS FULL ANALYSIS
SELECT instrument, fno.symbol, eq.current_price AS stock_price, eq.max_price, eq.min_price, expiry_date, strike_price, option_type, MAX(settle_price), MIN(settle_price), SUM(CASE WHEN trade_date = max_trade_date THEN settle_price else 0 END) AS current_price, SUM(CASE WHEN trade_date = max_trade_date THEN open_interest else 0 END) AS current_open_interest, (((MAX(settle_price) - SUM(CASE WHEN trade_date = max_trade_date THEN settle_price else 0 END)) / MAX(settle_price)) * 100)::integer AS drop_percentage FROM fno_history fno INNER JOIN (SELECT f.symbol, MIN(close_price) AS min_price, MAX(close_price) AS max_price, SUM(CASE WHEN e.trade_date = (SELECT MAX(trade_date) FROM trade_dates) THEN close_price ELSE 0 END) AS current_price, MAX(e.trade_date) AS max_trade_date FROM eq_history e INNER JOIN fno_stock_symbols f ON f.symbol = e.symbol AND f.active = true AND e.series = 'EQ' AND e.trade_date IS NOT NULL INNER JOIN (SELECT trade_date FROM trade_dates WHERE trade_date <= (SELECT MAX(trade_date) FROM trade_dates) ORDER BY trade_date DESC LIMIT 20) AS t ON e.trade_date = t.trade_date GROUP BY f.symbol HAVING COUNT(*) >= 20 ORDER BY (stddev(close_price)/avg(close_price) * 100) LIMIT 20) AS eq ON eq.symbol = fno.symbol AND expiry_date = '2022-03-31' AND instrument = 'OPTSTK' GROUP BY instrument, fno.symbol, eq.current_price, eq.max_price, eq.min_price, expiry_date, strike_price, option_type HAVING SUM(CASE WHEN trade_date = max_trade_date THEN open_interest else 0 END) > 0 ORDER BY SUM(CASE WHEN trade_date = max_trade_date THEN open_interest else 0 END) DESC LIMIT 50;

# FIND MISSING IDX OR FO DATA FOR ANY TRADING DAYS
SELECT e.trade_date AS e_trade_date, f.trade_date AS f_trade_date, i.trade_date AS i_trade_date FROM (SELECT DISTINCT trade_date FROM eq_history) AS e FULL JOIN (SELECT DISTINCT trade_date FROM fno_history) AS f ON e.trade_date = f.trade_date FULL JOIN (SELECT DISTINCT trade_date FROM idx_history) AS i ON i.trade_date = e.trade_date WHERE (f.trade_date IS NULL OR i.trade_date IS NULL) ORDER BY e.trade_date;